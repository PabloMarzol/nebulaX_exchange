import { getSemaphore } from "@henrygd/semaphore";
import { getWalletAddress, signL1Action, signMultiSigAction, signUserSignedAction } from "../../../signing/mod.js";
import { assertSuccessResponse } from "./_errors.js";
import { globalNonceManager } from "./_nonce.js";
import { getSignatureChainId } from "./_helpers.js";
export async function executeL1Action(config, request, signal) {
    const { transport } = config;
    const { action, vaultAddress, expiresAfter } = request;
    // Sequential request execution to prevent nonce race conditions at the network layer
    const walletAddress = "signers" in config
        ? await getWalletAddress(config.signers[0])
        : await getWalletAddress(config.wallet);
    const walletKey = `@nktkas/hyperliquid:${walletAddress}:${config.transport.isTestnet}`;
    const sem = getSemaphore(walletKey);
    await sem.acquire();
    // Main logic
    try {
        const nonce = globalNonceManager.getNonce();
        // Multi-signature request
        if ("signers" in config) {
            const { signers, multiSigUser } = config;
            const outerSigner = walletAddress;
            // Sign an L1 action for each signer
            const signatures = await Promise.all(signers.map(async (signer) => {
                const signature = await signL1Action({
                    wallet: signer,
                    action: [multiSigUser, outerSigner, action],
                    nonce,
                    isTestnet: transport.isTestnet,
                    vaultAddress,
                    expiresAfter,
                });
                signature.r = signature.r.replace(/^0x0+/, "0x");
                signature.s = signature.s.replace(/^0x0+/, "0x");
                return signature;
            }));
            // Send a request via multi-sign action
            return await executeMultiSigAction({ ...config, wallet: signers[0] }, {
                action: {
                    type: "multiSig",
                    signatureChainId: await getSignatureChainId(config),
                    signatures,
                    payload: { multiSigUser, outerSigner, action },
                },
                vaultAddress,
                expiresAfter,
                nonce,
            }, signal, false);
        }
        else { // Single-signature request
            const { wallet } = config;
            // Sign an L1 action
            const signature = await signL1Action({
                wallet,
                action,
                nonce,
                isTestnet: transport.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const response = await transport.request("exchange", { action, signature, nonce, vaultAddress, expiresAfter }, signal);
            assertSuccessResponse(response);
            return response;
        }
    }
    finally {
        // Release semaphore
        sem.release();
    }
}
export async function executeUserSignedAction(config, request, types, signal) {
    const { transport } = config;
    const { action } = request;
    // Sequential request execution to prevent nonce race conditions at the network layer
    const walletAddress = "signers" in config
        ? await getWalletAddress(config.signers[0])
        : await getWalletAddress(config.wallet);
    const walletKey = `@nktkas/hyperliquid:${walletAddress}:${config.transport.isTestnet}`;
    const sem = getSemaphore(walletKey);
    await sem.acquire();
    // Main logic
    try {
        const nonce = globalNonceManager.getNonce();
        if ("time" in action)
            request.action.time = nonce;
        if ("nonce" in action)
            request.action.nonce = nonce;
        // Multi-signature request
        if ("signers" in config) {
            const { signers, multiSigUser } = config;
            const outerSigner = walletAddress;
            // Sign a user-signed action for each signer
            const signatures = await Promise.all(signers.map(async (signer) => {
                const signature = await signUserSignedAction({
                    wallet: signer,
                    action: {
                        payloadMultiSigUser: multiSigUser,
                        outerSigner,
                        ...action,
                    },
                    types,
                });
                signature.r = signature.r.replace(/^0x0+/, "0x");
                signature.s = signature.s.replace(/^0x0+/, "0x");
                return signature;
            }));
            // Send a request via multi-sign action
            return await executeMultiSigAction({ ...config, wallet: signers[0] }, {
                action: {
                    type: "multiSig",
                    signatureChainId: action.signatureChainId,
                    signatures,
                    payload: { multiSigUser, outerSigner, action },
                },
                nonce,
            }, signal, false);
        }
        else { // Single-signature request
            const { wallet } = config;
            // Sign a user-signed action
            const signature = await signUserSignedAction({ wallet, action, types });
            // Send a request
            const response = await transport.request("exchange", { action, signature, nonce }, signal);
            assertSuccessResponse(response);
            return response;
        }
    }
    finally {
        // Release semaphore and nonce manager
        sem.release();
    }
}
export async function executeMultiSigAction(config, request, signal, semaphore = true) {
    const { transport, wallet } = config;
    const { action, nonce, vaultAddress, expiresAfter } = request;
    // Sequential request execution to prevent nonce race conditions at the network layer
    let sem;
    if (semaphore) {
        const walletAddress = await getWalletAddress(config.wallet);
        const walletKey = `@nktkas/hyperliquid:${walletAddress}:${config.transport.isTestnet}`;
        sem = getSemaphore(walletKey);
        await sem.acquire();
    }
    // Main logic
    try {
        // Sign a multi-signature action
        const signature = await signMultiSigAction({
            wallet,
            action,
            nonce,
            isTestnet: transport.isTestnet,
            vaultAddress,
            expiresAfter,
        });
        // Send a request
        const response = await transport.request("exchange", { action, signature, nonce, vaultAddress, expiresAfter }, signal);
        assertSuccessResponse(response);
        return response;
    }
    finally {
        // Release semaphore if used
        sem?.release();
    }
}
//# sourceMappingURL=_execute.js.map