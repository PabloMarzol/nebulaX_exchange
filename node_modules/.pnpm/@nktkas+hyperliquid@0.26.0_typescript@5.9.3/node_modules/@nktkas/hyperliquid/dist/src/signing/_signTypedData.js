/**
 * Abstract interfaces and utilities for signing typed data with various wallet implementations.
 * Supports ethers.js (v5 and v6) and viem wallets.
 */
import * as v from "valibot";
import { HyperliquidError } from "../_base.js";
const AbstractEthersV6Signer = v.object({
    signTypedData: v.pipe(v.function(), v.check((fn) => fn.length === 3)),
    getAddress: v.function(),
    provider: v.nullish(v.object({ getNetwork: v.function() })),
});
const AbstractEthersV5Signer = v.object({
    _signTypedData: v.pipe(v.function(), v.check((fn) => fn.length === 3)),
    getAddress: v.function(),
    provider: v.nullish(v.object({ getNetwork: v.function() })),
});
const AbstractViemJsonRpcAccountSchema = v.object({
    signTypedData: v.pipe(v.function(), v.check((fn) => fn.length === 1 || fn.length === 2)),
    getAddresses: v.function(),
    getChainId: v.function(),
});
const AbstractViemLocalAccountSchema = v.object({
    signTypedData: v.pipe(v.function(), v.check((fn) => fn.length === 1 || fn.length === 2)),
    address: v.string(),
});
/** Thrown when an error occurs in AbstractWallet operations (e.g., signing, getting address). */
export class AbstractWalletError extends HyperliquidError {
    constructor(message, options) {
        super(message, options);
        this.name = "AbstractWalletError";
    }
}
export async function signTypedData(args) {
    const { wallet, domain, types, primaryType, message } = args;
    let signature;
    if (v.is(AbstractViemJsonRpcAccountSchema, wallet) || v.is(AbstractViemLocalAccountSchema, wallet)) {
        try {
            signature = await wallet.signTypedData({
                domain,
                types: {
                    EIP712Domain: [
                        { name: "name", type: "string" },
                        { name: "version", type: "string" },
                        { name: "chainId", type: "uint256" },
                        { name: "verifyingContract", type: "address" },
                    ],
                    ...types,
                },
                primaryType,
                message,
            });
        }
        catch (error) {
            throw new AbstractWalletError("Failed to sign typed data with viem wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    else if (v.is(AbstractEthersV6Signer, wallet)) {
        try {
            signature = await wallet.signTypedData(domain, types, message);
        }
        catch (error) {
            throw new AbstractWalletError("Failed to sign typed data with ethers v6 wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    else if (v.is(AbstractEthersV5Signer, wallet)) {
        try {
            signature = await wallet._signTypedData(domain, types, message);
        }
        catch (error) {
            throw new AbstractWalletError("Failed to sign typed data with ethers v5 wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    else {
        throw new AbstractWalletError("Failed to sign typed data: unknown wallet");
    }
    return splitSignature(signature);
}
function splitSignature(signature) {
    const r = `0x${signature.slice(2, 66)}`;
    const s = `0x${signature.slice(66, 130)}`;
    const v = parseInt(signature.slice(130, 132), 16);
    return { r, s, v };
}
// -------------------- Utils --------------------
/** Get the chain ID of the wallet. */
export async function getWalletChainId(wallet) {
    if (v.is(AbstractViemJsonRpcAccountSchema, wallet)) {
        try {
            const chainId = await wallet.getChainId();
            return `0x${chainId.toString(16)}`;
        }
        catch (error) {
            throw new AbstractWalletError("Failed to get chain ID from viem wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    if (v.is(AbstractEthersV6Signer, wallet)) {
        if ("provider" in wallet && wallet.provider) {
            try {
                const network = await wallet.provider.getNetwork();
                return `0x${network.chainId.toString(16)}`;
            }
            catch (error) {
                throw new AbstractWalletError("Failed to get chain ID from ethers v6 wallet. See cause for details.", {
                    cause: error,
                });
            }
        }
    }
    if (v.is(AbstractEthersV5Signer, wallet)) {
        if ("provider" in wallet && wallet.provider) {
            try {
                const network = await wallet.provider.getNetwork();
                return `0x${network.chainId.toString(16)}`;
            }
            catch (error) {
                throw new AbstractWalletError("Failed to get chain ID from ethers v5 wallet. See cause for details.", {
                    cause: error,
                });
            }
        }
    }
    return "0x1";
}
/** Get the lowercase wallet address from various wallet types. */
export async function getWalletAddress(wallet) {
    if (v.is(AbstractViemJsonRpcAccountSchema, wallet)) {
        try {
            const addresses = await wallet.getAddresses();
            return addresses[0].toLowerCase();
        }
        catch (error) {
            throw new AbstractWalletError("Failed to get address from viem wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    if (v.is(AbstractViemLocalAccountSchema, wallet)) {
        return wallet.address.toLowerCase();
    }
    if (v.is(AbstractEthersV6Signer, wallet) || v.is(AbstractEthersV5Signer, wallet)) {
        try {
            const address = await wallet.getAddress();
            return address.toLowerCase();
        }
        catch (error) {
            throw new AbstractWalletError("Failed to get address from ethers wallet. See cause for details.", {
                cause: error,
            });
        }
    }
    throw new AbstractWalletError("Failed to get wallet address: unknown wallet");
}
//# sourceMappingURL=_signTypedData.js.map